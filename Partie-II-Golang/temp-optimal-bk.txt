// optimal implementation for the Knapsack using a specific number of goroutines
func KnapSackOptimal(W int, wt []int, val []int, 
	result chan int, result_characters chan string, availableItems []Item)  {

	fmt.Println("Number of active go routines : ",runtime.NumGoroutine())


	if (len(wt) == 0 || W==0) {
		result <- 0 
		result_characters <- ""
		return
	}

	// seuil
	if (len(wt) <= 1){
		last := len(wt)-1
		if (wt[last] > W){
			// do not include the item
			result <- 0
			result_characters <- ""
			return
		}else{
			// include the item
			result <- val[last]
			result_characters <- getItemRepresentation(availableItems, val[last], wt[last])
			return
		}
	}

	// 
	last := len(wt)-1

	// midLen := 0
	// if len(wt) % 2 == 0{
	// 	midLen = len(wt)/2-1
	// } else {
	// 	midLen = (len(wt)+1)/2-1
	// }


	if (wt[last] > W){ // the item can be included in the Knapsack
		// initialize a new goroutine without that item but the keep the initial channels passed as parameters
		go KnapSackOptimal(W, wt[:last], val[:last], result, result_characters, availableItems)
		return // terminate the goroutine
	}else{ // the item could  be included in the Knapsack

		// channels for collecting 
		// first half channels
		included := make(chan int)      // collect the next value after the nth item is included
		not_included := make(chan int)  // collect the next value after the nth item is not included
		// second half channel
		// included_sec := make(chan int)
		// not_included_sec := make(chan int)

		// channels for collecting the included characters
		// first half channels
		character_included := make(chan string)       // a channel for when the nth item is included
		character_not_included := make(chan string)	// a channel for when the nth item is not included

		// second half channels
		// character_included_sec := make(chan string)
		// character_not_included_sec :=  make(chan string)

		// initialize the parallel sequences
		// first half of the slices
		// go KnapSackOptimal(W - wt[midLen], wt[:midLen], val[:midLen], included, character_included, availableItems)
		// go KnapSackOptimal(W, wt[:midLen], val[:midLen],not_included, character_not_included, availableItems)

		// // fmt.Printf("\n> %v\n", wt[midLen:last]) // < Debug purpose
		// // second half of the slices
		// go KnapSackOptimal(W - wt[last], wt[midLen+1:last], val[midLen+1:last], included_sec, character_included_sec, availableItems)
		// go KnapSackOptimal(W, wt[midLen+1:last], val[midLen+1:last],not_included_sec, character_not_included_sec, availableItems)

		for i:= last ; i >=0; i-- {
			go KnapSackOptimal(W - wt[i], wt[:i], val[:i], included, character_included, availableItems)
			go KnapSackOptimal(W, wt[:i], val[:i],not_included, character_not_included, availableItems)
		}

		// get the corresponding item values
		// first half
		// nth_included := val[midLen] + (<-included)// if the nth is included
		// nth_not_included := (<-not_included) // if the nth item is not included
		// get the corresponding item 
		
		nth_included := val[last] + (<-included) // if the nth is included
		nth_not_included := (<-not_included)	 // if the nth item is not included

		// get the maximum value between the two possibilities
		max := Max(nth_included, nth_not_included)


		// // get the maximum value of the first half 
		// first_half_max := Max(nth_included, nth_not_included)

		// // second half
		// nth_included_sec := val[last] + (<-included_sec)
		// nth_not_included_sec := (<-not_included_sec)

		// // get the maximum value for the second half
		// second_half_max := Max(nth_included_sec, nth_not_included_sec)

		// // get the maximum value between the two possibilities
		// max := Max(first_half_max, second_half_max)

		// fmt.Printf("\nfirst half: %d - second half : %d\n", first_half_max, second_half_max) // Debug purpose
		// write the value to the channel 

		result <- max 

		// get the corresponding items representation
		if max == nth_included {
			// find the item corresponding to the 
			repr := getItemRepresentation(availableItems, val[last], wt[last])
			// add the character found to the result
			result_characters <- repr + " " + <-character_included
		}else{
			result_characters <- (<-character_not_included) + " "
		}

		// // get the corresponding items representation
		// if max == first_half_max { // first half max
		// 	if max == nth_included {
		// 		repr := getItemRepresentation(availableItems, val[midLen], wt[midLen])
		// 		// add the character found to the result
		// 		result_characters <- repr + " " + <-character_included + " " 
		// 	}else{
		// 		result_characters <- (<-character_not_included) + " "
		// 	}
		// }else{ // second half max
		// 	if max == nth_included_sec {
		// 		repr := getItemRepresentation(availableItems, val[last], wt[last])
		// 		// add the character found to the result
		// 		result_characters <- repr + " " + <-character_included_sec + " "
		// 	}else{
		// 		result_characters <- (<-character_not_included_sec) +" " 
		// 	}
		// }
		
		return // terminate the routine
	}

}

--------------------------
// optimal implementation for the Knapsack using a specific number of goroutines
func KnapSackOptimal(W int, wt []int, val []int, 
	result chan int, result_characters chan string, availableItems []Item)  {

	fmt.Println("Number of active go routines : ",runtime.NumGoroutine())


	if (len(wt) == 0 || W==0) {
		result <- 0 
		result_characters <- ""
		return
	}

	// seuil
	if (len(wt) <= 1){
		last := len(wt)-1
		if (wt[last] > W){
			// do not include the item
			result <- 0
			result_characters <- ""
			return
		}else{
			// include the item
			result <- val[last]
			result_characters <- getItemRepresentation(availableItems, val[last], wt[last])
			return
		}
	}

	// 
	last := len(wt)-1

	if (wt[last] > W){ // the item can not be included in the Knapsack
		// initialize a new goroutine without that item but the keep the initial channels passed as parameters
		go KnapSackOptimal(W, wt[:last], val[:last], result, result_characters, availableItems)
		return // terminate the goroutine
	}else{ // the item could  be included in the Knapsack

		// channels for collecting 
		// first half channels
		included := make(chan int)      // collect the next value after the nth item is included
		not_included := make(chan int)  // collect the next value after the nth item is not included
		// second half channel
		// included_sec := make(chan int)
		// not_included_sec := make(chan int)

		// channels for collecting the included characters
		// first half channels
		character_included := make(chan string)       // a channel for when the nth item is included
		character_not_included := make(chan string)	// a channel for when the nth item is not included

		// second half channels
		// character_included_sec := make(chan string)
		// character_not_included_sec :=  make(chan string)

		for i:= last ; i >=0; i-- {
			go KnapSackOptimal(W - wt[i], wt[:i], val[:i], included, character_included, availableItems)
			go KnapSackOptimal(W, wt[:i], val[:i],not_included, character_not_included, availableItems)
		}

		
		nth_included := val[last] + (<-included) // if the nth is included
		nth_not_included := (<-not_included)	 // if the nth item is not included

		// get the maximum value between the two possibilities
		max := Max(nth_included, nth_not_included)

		// fmt.Printf("\nfirst half: %d - second half : %d\n", first_half_max, second_half_max) // Debug purpose
		// write the value to the channel 
		result <- max 

		// get the corresponding items representation
		if max == nth_included {
			// find the item corresponding to the 
			repr := getItemRepresentation(availableItems, val[last], wt[last])
			// add the character found to the result
			result_characters <- repr + " " + <-character_included
		}else{
			result_characters <- (<-character_not_included) + " "
		}

		return // terminate the routine
	}

}